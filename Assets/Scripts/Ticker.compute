// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Point {
  float4 color;
  int age;
};

struct Spread {
  float4 color;
  uint pattern;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
// RWTexture2D<float4> Result;
int height;
int width;
int lifeTime;
int deathTimeMult;
int patternCount;
RWStructuredBuffer<Point> points;
RWStructuredBuffer<Spread> spreads;
RWTexture2D<float4> board;

float4 black = float4(0,0,0,1);

[numthreads(100,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
  Point p = points[id.x];
  if (!all(p.color == black)) p.age++;
  // p.color = float4(xpos, 0, 0, 1);
  
  // PATTERN :: [NW, N, NE, W, E, SW, S, SE]
  float4 possibleColors[8];
  Point neighbours[8];
  for (int i = 0; i < 8; i++) {
    neighbours[i] = p;
  }


  uint uWidth = (uint) width;
  uint uHeight = (uint) height;


  bool notNorthBorder = id.x >= uWidth;
  bool notWestBorder  = (id.x % uWidth) > 0;
  bool notEastBorder  = (id.x % uWidth) != uWidth-1;
  bool notSouthBorder = id.x / uWidth != uHeight-1;

//   bool notNorthBorder = true;
//   bool notWestBorder;
//   bool notEastBorder  = true;
//   bool notSouthBorder = true;

//   int localPos = id.x;
//   while(localPos > width) {
//     localPos -= width;
//   }

//   notWestBorder = localPos > 0;
//   notEastBorder = localPos != width - 1;

  /// GATHERING ALL THE NEIGHBOURS
  if (notNorthBorder && notWestBorder) {
    Point NW = points[id.x-1 - width];
    // possibleColors[0] = NW.color;
    neighbours[0] = NW;
  }

  if (notNorthBorder) {
    Point N = points[id.x - width];
    neighbours[1] = N;
  }

  if (notNorthBorder && notEastBorder) {
    Point NE = points[id.x+1 - width];
    neighbours[2] = NE;
  }

  if (notWestBorder) {
    Point W = points[id.x-1];
    neighbours[3] = W;
  }

  if (notEastBorder) {
    Point E = points[id.x+1];
    neighbours[4] = E;
  }

  if (notSouthBorder && notWestBorder) {
    Point SW = points[id.x-1 + width];
    neighbours[5] = SW;
  }

  if (notSouthBorder) {
    Point S = points[id.x + width];
    neighbours[6] = S;
  }

  if (notSouthBorder && notEastBorder) {
    Point SE = points[id.x+1 + width];
    neighbours[7] = SE;
  }

  int colorID = 0;
  int yougestAge = -1;
  float4 youngestColour;
  uint grow;

  /// LOOPING OVER NEIGHBOURS AND THE PATTERNS
  for (int j = 0; j < patternCount; j++) {
    Spread s = spreads[j];
    for (int i = 0; i < 8; i++) {
      Point neighbour = neighbours[i];
      if (all(s.color == neighbour.color)) {
      //   // then go into proper neighbour in pattern, to see if grow
      //   // [NW, N, NE, W, E, SW, S, SE]
      //   // [0 , 0,  0, 0, 0,  1, 0,  1]
        // if (i == 7) grow = s.pattern & 1;
        // else grow = s.pattern & (1 << 7-i);
        grow = s.pattern & (1 << 7-i);

        if (grow != 0) {
          if (yougestAge == -1 || yougestAge > neighbour.age) {
            youngestColour = neighbour.color;
            yougestAge = neighbour.age;
          }
          possibleColors[colorID] = neighbour.color;
          colorID++;
        }
      }
    }
  }

  /// SETTING THE COLOUR
  // if (colorID > 0) p.color = possibleColors[0];
  if (yougestAge != -1 && !all(youngestColour == p.color)) {
    p.color = youngestColour;
    p.age = 0;
  }

  if (p.age == lifeTime) {
    p.color = black;
    // p.age = 0;
  } else if (p.age > lifeTime * deathTimeMult) {
    p.color = black;
    p.age = 0;
  }
  points[id.x] = p;

  ////// TEXTURE LOGIC
  int2 pos = {id.x % width, id.x / width};
  board[pos] = p.color;

  // Set p.color using some rule, -- FCFS, Majority, LCFS, Colour priority(racism)
  // Result[pos] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
